From bc79df5ba4bdc972c4c70e92cfe7cd576baf7213 Mon Sep 17 00:00:00 2001
From: "Jeroen van Meeuwen (Kolab Systems)" <vanmeeuwen@kolabsys.com>
Date: Sat, 29 Sep 2012 12:12:14 +0100
Subject: [PATCH] Update sysvinit scripts (#972)

---
 kolabd/kolabd.sysvinit             | 178 ++++++++++++++++++++++++----------
 saslauthd/kolab-saslauthd.sysvinit | 189 ++++++++++++++++++++++++++-----------
 wallace/wallace.sysvinit           | 177 ++++++++++++++++++++++++----------
 3 files changed, 387 insertions(+), 157 deletions(-)

diff --git a/kolabd/kolabd.sysvinit b/kolabd/kolabd.sysvinit
index 302dfa9..ca6802a 100644
--- a/kolabd/kolabd.sysvinit
+++ b/kolabd/kolabd.sysvinit
@@ -6,18 +6,18 @@
 # description:      The Kolab server is a server process which synchronizes
 #                   LDAP, SQL and other authentication databases with Cyrus IMAP,
 #                   Dovecot or other IMAP servers.
-# processname: kolabd
+# processname:      kolabd
 
 ### BEGIN INIT INFO
-# Provides: kolabd
-# Default-Start: -
-# Default-Stop: 0 1 2 6
-# Required-Start: $remote_fs $local_fs $network
-# Required-Stop: $remote_fs $local_fs $network
-# Short-Description: Start/Stop the Kolab Server daemon
-# Description:      The Kolab server is a server process which synchronizes
-#                   LDAP, SQL and other authentication databases with Cyrus IMAP,
-#                   Dovecot or other IMAP servers.
+# Provides:             kolabd
+# Default-Start:        -
+# Default-Stop:         0 1 2 6
+# Required-Start:       $remote_fs $local_fs $network
+# Required-Stop:        $remote_fs $local_fs $network
+# Short-Description:    Start/Stop the Kolab Server daemon
+# Description:          The Kolab server is a server process which synchronizes
+#                       LDAP, SQL and other authentication databases with Cyrus
+#                       IMAP, Dovecot or other IMAP servers.
 ### END INIT INFO
 
 # Source function library.
@@ -27,6 +27,8 @@ fi
 
 # Source our configuration file for these variables.
 FLAGS="--fork -l warning"
+USER="kolab"
+GROUP="kolab"
 
 if [ -f /etc/sysconfig/kolabd ] ; then
     . /etc/sysconfig/kolabd
@@ -36,6 +38,14 @@ if [ -f /etc/default/kolabd ]; then
     . /etc/default/kolabd
 fi
 
+if [ -f /lib/init/vars.sh ]; then
+    . /lib/init/vars.sh
+fi
+
+if [ -f /lib/lsb/init-functions ]; then
+    . /lib/lsb/init-functions
+fi
+
 RETVAL=0
 
 # Set up some common variables before we launch into what might be
@@ -45,23 +55,75 @@ path=/usr/sbin/kolabd
 lockfile=/var/lock/subsys/$prog
 pidfile=/var/run/kolabd/kolabd.pid
 
+if [ ! -d "$(dirname $pidfile)" ]; then
+    mkdir -p $(dirname $pidfile)
+    chown $USER:$GROUP $(dirname $pidfile)
+fi
+
 start() {
     [ -x $path ] || exit 5
-    echo -n $"Starting $prog: "
-    daemon $DAEMONOPTS $path -p $pidfile $FLAGS
-    RETVAL=$?
-    echo
-    [ $RETVAL -eq 0 ] && touch $lockfile
-    return $RETVAL
+    if [ -x "$(which start-stop-daemon 2>/dev/null)" ]; then
+        [ "$VERBOSE" != no ] && log_daemon_msg "Starting $prog " "$prog"
+        # Return
+        #   0 if daemon has been started
+        #   1 if daemon was already running
+        #   2 if daemon could not be started
+        start-stop-daemon --start --quiet --pidfile $pidfile --exec $path \
+            --test > /dev/null || retval=1
+        start-stop-daemon --start --quiet --pidfile $pidfile --exec $path -- \
+            $DAEMONOPTS $FLAGS || retval=2
+
+        case "$retval" in
+            0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
+            2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
+        esac
+
+    else
+        echo -n $"Starting $prog: "
+        daemon $DAEMONOPTS $path -p $pidfile $FLAGS
+        RETVAL=$?
+        echo
+        [ $RETVAL -eq 0 ] && touch $lockfile
+        return $RETVAL
+    fi
 }
 
 stop() {
-    echo -n $"Stopping $prog: "
-    killproc $prog
-    RETVAL=$?
-    echo
-    [ $RETVAL -eq 0 ] && rm -f $lockfile
-    return $RETVAL
+    if [ -x "$(which start-stop-daemon 2>/dev/null)" ]; then
+        [ "$VERBOSE" != no ] && log_daemon_msg "Stopping $prog" "$prog"
+        # Return
+        #   0 if daemon has been stopped
+        #   1 if daemon was already stopped
+        #   2 if daemon could not be stopped
+        #   other if a failure occurred
+        start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $pidfile --name $prog
+        retval="$?"
+        [ "$retval" = 2 ] && retval=2
+        # Wait for children to finish too if this is a daemon that forks
+        # and if the daemon is only ever run from this initscript.
+        # If the above conditions are not satisfied then add some other code
+        # that waits for the process to drop all resources that could be
+        # needed by services started subsequently.  A last resort is to
+        # sleep for some time.
+        start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec $path
+        [ "$?" = 2 ] && retval=2
+
+        case "$retval" in
+            0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
+            2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
+        esac
+
+        # Many daemons don't delete their pidfiles when they exit.
+        rm -f $PIDFILE
+        return "$retval"
+    else
+        echo -n $"Stopping $prog: "
+        killproc $prog
+        RETVAL=$?
+        echo
+        [ $RETVAL -eq 0 ] && rm -f $lockfile
+        return $RETVAL
+    fi
 }
 
 restart() {
@@ -87,34 +149,50 @@ rh_status_q() {
 }
 
 case "$1" in
-  start)
-    rh_status_q && exit 0
-    start
-    ;;
-  stop)
-    rh_status_q || exit 0
-    stop
-    ;;
-  restart)
-    restart
-    ;;
-  reload)
-    rh_status_q || exit 7
-    reload
-    ;;
-  force-reload)
-    force_reload
-    ;;
-  status)
-    rh_status
-    ;;
-  condrestart|try-restart)
-    rh_status_q || exit 0
-    restart
-    ;;
-  *)
-    echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
-    exit 2
+    start)
+            if [ "$(status_of_proc >/dev/null 2>&1; echo $?)" == "127" ]; then
+                rh_status_q || exit 0
+            fi
+            start
+        ;;
+
+    stop)
+            if [ "$(status_of_proc >/dev/null 2>&1; echo $?)" == "127" ]; then
+                rh_status_q || exit 0
+            fi
+            stop
+        ;;
+
+    restart)
+            restart
+        ;;
+
+    reload)
+            rh_status_q || exit 7
+            reload
+        ;;
+
+    force-reload)
+            force_reload
+        ;;
+
+    status)
+            if [ "$(status_of_proc >/dev/null 2>&1; echo $?)" == "3" ]; then
+                status_of_proc "$path" "$prog" && exit 0 || exit $?
+            else
+                rh_status
+            fi
+        ;;
+
+    condrestart|try-restart)
+            rh_status_q || exit 0
+            restart
+        ;;
+
+    *)
+            echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
+            exit 2
+        ;;
 esac
 
 exit $?
diff --git a/saslauthd/kolab-saslauthd.sysvinit b/saslauthd/kolab-saslauthd.sysvinit
index 033bbc7..759ae11 100644
--- a/saslauthd/kolab-saslauthd.sysvinit
+++ b/saslauthd/kolab-saslauthd.sysvinit
@@ -1,31 +1,33 @@
 #! /bin/bash
 #
-# kolab-saslauthd   Start/Stop the SASL authentication daemon
+# kolab-saslauthd       Start/Stop the SASL authentication daemon
 #
-# chkconfig:        - 65 10
-# description:      The Kolab saslauthd is a server process which handles \
-#                   authentication requests on behalf of the cyrus-sasl library.
-# processname: kolab-saslauthd
+# chkconfig:            - 65 10
+# description:          The Kolab saslauthd is a server process which handles \
+#                       authentication requests on behalf of the cyrus-sasl library.
+# processname:          kolab-saslauthd
 
 ### BEGIN INIT INFO
-# Provides: kolab-saslauthd
-# Default-Start: -
-# Default-Stop: 0 1 2 6
-# Required-Start: $remote_fs $local_fs $network
-# Required-Stop: $remote_fs $local_fs $network
-# Short-Description: Start/Stop the Kolab SASL authentication daemon
-# Description: The Kolab saslauthd is a server process which handles \
-#              authentication requests on behalf of the cyrus-sasl library.
+# Provides:             kolab-saslauthd
+# Default-Start:        -
+# Default-Stop:         0 1 2 6
+# Required-Start:       $remote_fs $local_fs $network
+# Required-Stop:        $remote_fs $local_fs $network
+# Short-Description:    Start/Stop the Kolab SASL authentication daemon
+# Description:          The Kolab saslauthd is a server process which handles \
+#                       authentication requests on behalf of the cyrus-sasl library.
 ### END INIT INFO
 
 # Source function library.
-if [ -f  /etc/init.d/functions ]; then
+if [ -f /etc/init.d/functions ]; then
     . /etc/init.d/functions
 fi
 
 # Source our configuration file for these variables.
-SOCKETDIR=/var/run/saslauthd
 FLAGS="--fork -l warning"
+SOCKETDIR=/var/run/saslauthd
+USER="root"
+GROUP="root"
 
 if [ -f /etc/sysconfig/kolab-saslauthd ] ; then
     . /etc/sysconfig/kolab-saslauthd
@@ -35,6 +37,14 @@ if [ -f /etc/default/kolab-saslauthd ]; then
     . /etc/default/kolab-saslauthd
 fi
 
+if [ -f /lib/init/vars.sh ]; then
+    . /lib/init/vars.sh
+fi
+
+if [ -f /lib/lsb/init-functions ]; then
+    . /lib/lsb/init-functions
+fi
+
 RETVAL=0
 
 # Set up some common variables before we launch into what might be
@@ -44,23 +54,76 @@ path=/usr/sbin/kolab-saslauthd
 lockfile=/var/lock/subsys/$prog
 pidfile=/var/run/kolab-saslauthd/kolab-saslauthd.pid
 
+if [ ! -d "$(dirname $pidfile)" ]; then
+    mkdir -p $(dirname $pidfile)
+    chown $USER:$GROUP $(dirname $pidfile)
+fi
+
 start() {
     [ -x $path ] || exit 5
-    echo -n $"Starting $prog: "
-    daemon $DAEMONOPTS $path -p $pidfile $FLAGS
-    RETVAL=$?
-    echo
-    [ $RETVAL -eq 0 ] && touch $lockfile
-    return $RETVAL
+
+    if [ -x "$(which start-stop-daemon 2>/dev/null)" ]; then
+        [ "$VERBOSE" != no ] && log_daemon_msg "Starting $prog " "$prog"
+        # Return
+        #   0 if daemon has been started
+        #   1 if daemon was already running
+        #   2 if daemon could not be started
+        start-stop-daemon --start --quiet --pidfile $pidfile --exec $path \
+            --test > /dev/null || retval=1
+        start-stop-daemon --start --quiet --pidfile $pidfile --exec $path -- \
+            $DAEMONOPTS $FLAGS || retval=2
+
+        case "$retval" in
+            0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
+            2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
+        esac
+
+    else
+        echo -n $"Starting $prog: "
+        daemon $DAEMONOPTS $path -p $pidfile $FLAGS
+        RETVAL=$?
+        echo
+        [ $RETVAL -eq 0 ] && touch $lockfile
+        return $RETVAL
+    fi
 }
 
 stop() {
-    echo -n $"Stopping $prog: "
-    killproc $prog
-    RETVAL=$?
-    echo
-    [ $RETVAL -eq 0 ] && rm -f $lockfile
-    return $RETVAL
+    if [ -x "$(which start-stop-daemon 2>/dev/null)" ]; then
+        [ "$VERBOSE" != no ] && log_daemon_msg "Stopping $prog" "$prog"
+        # Return
+        #   0 if daemon has been stopped
+        #   1 if daemon was already stopped
+        #   2 if daemon could not be stopped
+        #   other if a failure occurred
+        start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $pidfile --name $prog
+        retval="$?"
+        [ "$retval" = 2 ] && retval=2
+        # Wait for children to finish too if this is a daemon that forks
+        # and if the daemon is only ever run from this initscript.
+        # If the above conditions are not satisfied then add some other code
+        # that waits for the process to drop all resources that could be
+        # needed by services started subsequently.  A last resort is to
+        # sleep for some time.
+        start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec $path
+        [ "$?" = 2 ] && retval=2
+
+        case "$retval" in
+            0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
+            2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
+        esac
+
+        # Many daemons don't delete their pidfiles when they exit.
+        rm -f $PIDFILE
+        return "$retval"
+    else
+        echo -n $"Stopping $prog: "
+        killproc $prog
+        RETVAL=$?
+        echo
+        [ $RETVAL -eq 0 ] && rm -f $lockfile
+        return $RETVAL
+    fi
 }
 
 restart() {
@@ -86,34 +149,50 @@ rh_status_q() {
 }
 
 case "$1" in
-  start)
-    rh_status_q && exit 0
-    start
-    ;;
-  stop)
-    rh_status_q || exit 0
-    stop
-    ;;
-  restart)
-    restart
-    ;;
-  reload)
-    rh_status_q || exit 7
-    reload
-    ;;
-  force-reload)
-    force_reload
-    ;;
-  status)
-    rh_status
-    ;;
-  condrestart|try-restart)
-    rh_status_q || exit 0
-    restart
-    ;;
-  *)
-    echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
-    exit 2
+    start)
+            if [ "$(status_of_proc >/dev/null 2>&1; echo $?)" == "127" ]; then
+                rh_status_q || exit 0
+            fi
+            start
+        ;;
+
+    stop)
+            if [ "$(status_of_proc >/dev/null 2>&1; echo $?)" == "127" ]; then
+                rh_status_q || exit 0
+            fi
+            stop
+        ;;
+
+    restart)
+            restart
+        ;;
+
+    reload)
+            rh_status_q || exit 7
+            reload
+        ;;
+
+    force-reload)
+            force_reload
+        ;;
+
+    status)
+            if [ "$(status_of_proc >/dev/null 2>&1; echo $?)" == "3" ]; then
+                status_of_proc "$path" "$prog" && exit 0 || exit $?
+            else
+                rh_status
+            fi
+        ;;
+
+    condrestart|try-restart)
+            rh_status_q || exit 0
+            restart
+        ;;
+
+    *)
+            echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
+            exit 2
+        ;;
 esac
 
 exit $?
diff --git a/wallace/wallace.sysvinit b/wallace/wallace.sysvinit
index 4848827..0f61062 100644
--- a/wallace/wallace.sysvinit
+++ b/wallace/wallace.sysvinit
@@ -2,18 +2,18 @@
 #
 # wallace  Start/Stop the Kolab server daemon Wallace
 #
-# chkconfig:        - 65 10
-# description:      The Kolab Wallace server daemon is a content filtering daemon.
-# processname: wallaced
+# chkconfig:            - 65 10
+# description:          The Kolab Wallace server daemon is a content filtering daemon.
+# processname:          wallaced
 
 ### BEGIN INIT INFO
-# Provides: wallaced
-# Default-Start: -
-# Default-Stop: 0 1 2 6
-# Required-Start: $remote_fs $local_fs $network
-# Required-Stop: $remote_fs $local_fs $network
-# Short-Description: Start/Stop the Kolab Server daemon
-# Description:      The Kolab Wallace server daemon is a content filtering daemon.
+# Provides:             wallaced
+# Default-Start:        -
+# Default-Stop:         0 1 2 6
+# Required-Start:       $remote_fs $local_fs $network
+# Required-Stop:        $remote_fs $local_fs $network
+# Short-Description:    Start/Stop the Kolab Server daemon
+# Description:          The Kolab Wallace server daemon is a content filtering daemon.
 ### END INIT INFO
 
 # Source function library.
@@ -34,6 +34,14 @@ if [ -f /etc/default/wallace ]; then
     . /etc/default/wallace
 fi
 
+if [ -f /lib/init/vars.sh ]; then
+    . /lib/init/vars.sh
+fi
+
+if [ -f /lib/lsb/init-functions ]; then
+    . /lib/lsb/init-functions
+fi
+
 RETVAL=0
 
 # Set up some common variables before we launch into what might be
@@ -43,26 +51,75 @@ path=/usr/sbin/wallaced
 lockfile=/var/lock/subsys/$prog
 pidfile=/var/run/wallaced/wallaced.pid
 
-[ ! -d "$(dirname ${pidfile})" ] && mkdir -p $(dirname ${pidfile})
-chown ${USER}:${GROUP} $(dirname ${pidfile})
+if [ ! -d "$(dirname $pidfile)" ]; then
+    mkdir -p $(dirname $pidfile)
+    chown $USER:$GROUP $(dirname $pidfile)
+fi
 
 start() {
     [ -x $path ] || exit 5
-    echo -n $"Starting $prog: "
-    daemon $DAEMONOPTS $path -p $pidfile $FLAGS
-    RETVAL=$?
-    echo
-    [ $RETVAL -eq 0 ] && touch $lockfile
-    return $RETVAL
+    if [ -x "$(which start-stop-daemon 2>/dev/null)" ]; then
+        [ "$VERBOSE" != no ] && log_daemon_msg "Starting $prog " "$prog"
+        # Return
+        #   0 if daemon has been started
+        #   1 if daemon was already running
+        #   2 if daemon could not be started
+        start-stop-daemon --start --quiet --pidfile $pidfile --exec $path \
+            --test > /dev/null || retval=1
+        start-stop-daemon --start --quiet --pidfile $pidfile --exec $path -- \
+            $DAEMONOPTS $FLAGS || retval=2
+
+        case "$retval" in
+            0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
+            2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
+        esac
+
+    else
+        echo -n $"Starting $prog: "
+        daemon $DAEMONOPTS $path -p $pidfile $FLAGS
+        RETVAL=$?
+        echo
+        [ $RETVAL -eq 0 ] && touch $lockfile
+        return $RETVAL
+    fi
 }
 
 stop() {
-    echo -n $"Stopping $prog: "
-    killproc $prog
-    RETVAL=$?
-    echo
-    [ $RETVAL -eq 0 ] && rm -f $lockfile
-    return $RETVAL
+    if [ -x "$(which start-stop-daemon 2>/dev/null)" ]; then
+        [ "$VERBOSE" != no ] && log_daemon_msg "Stopping $prog" "$prog"
+        # Return
+        #   0 if daemon has been stopped
+        #   1 if daemon was already stopped
+        #   2 if daemon could not be stopped
+        #   other if a failure occurred
+        start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $pidfile --name $prog
+        retval="$?"
+        [ "$retval" = 2 ] && retval=2
+        # Wait for children to finish too if this is a daemon that forks
+        # and if the daemon is only ever run from this initscript.
+        # If the above conditions are not satisfied then add some other code
+        # that waits for the process to drop all resources that could be
+        # needed by services started subsequently.  A last resort is to
+        # sleep for some time.
+        start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec $path
+        [ "$?" = 2 ] && retval=2
+
+        case "$retval" in
+            0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
+            2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
+        esac
+
+        # Many daemons don't delete their pidfiles when they exit.
+        rm -f $PIDFILE
+        return "$retval"
+    else
+        echo -n $"Stopping $prog: "
+        killproc $prog
+        RETVAL=$?
+        echo
+        [ $RETVAL -eq 0 ] && rm -f $lockfile
+        return $RETVAL
+    fi
 }
 
 restart() {
@@ -88,34 +145,50 @@ rh_status_q() {
 }
 
 case "$1" in
-  start)
-    rh_status_q && exit 0
-    start
-    ;;
-  stop)
-    rh_status_q || exit 0
-    stop
-    ;;
-  restart)
-    restart
-    ;;
-  reload)
-    rh_status_q || exit 7
-    reload
-    ;;
-  force-reload)
-    force_reload
-    ;;
-  status)
-    rh_status
-    ;;
-  condrestart|try-restart)
-    rh_status_q || exit 0
-    restart
-    ;;
-  *)
-    echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
-    exit 2
+    start)
+            if [ "$(status_of_proc >/dev/null 2>&1; echo $?)" == "127" ]; then
+                rh_status_q || exit 0
+            fi
+            start
+        ;;
+
+    stop)
+            if [ "$(status_of_proc >/dev/null 2>&1; echo $?)" == "127" ]; then
+                rh_status_q || exit 0
+            fi
+            stop
+        ;;
+
+    restart)
+            restart
+        ;;
+
+    reload)
+            rh_status_q || exit 7
+            reload
+        ;;
+
+    force-reload)
+            force_reload
+        ;;
+
+    status)
+            if [ "$(status_of_proc >/dev/null 2>&1; echo $?)" == "3" ]; then
+                status_of_proc "$path" "$prog" && exit 0 || exit $?
+            else
+                rh_status
+            fi
+        ;;
+
+    condrestart|try-restart)
+            rh_status_q || exit 0
+            restart
+        ;;
+
+    *)
+            echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
+            exit 2
+        ;;
 esac
 
 exit $?
-- 
1.7.11.4

